<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>C&#43;&#43;primer学习笔记(二) - JackyLove的小窝</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="JackyLove" /><meta name="description" content="字符串、向量和数组 命名空间的using声明 一般我们如果要使用标准库中定义的变量，需要在程序中用namespace::name来表示，例如 st" /><meta name="keywords" content="Hugo, code, linux, c&#43;&#43;, python, go, javascript" />






<meta name="generator" content="Hugo 0.54.0 with even 4.0.0" />


<link rel="canonical" href="https://www.jackylove.me/post/c&#43;&#43;primer-2/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="C&#43;&#43;primer学习笔记(二)" />
<meta property="og:description" content="字符串、向量和数组 命名空间的using声明 一般我们如果要使用标准库中定义的变量，需要在程序中用namespace::name来表示，例如 st" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.jackylove.me/post/c&#43;&#43;primer-2/" />
<meta property="article:published_time" content="2019-03-29T11:56:35&#43;08:00"/>
<meta property="article:modified_time" content="2019-03-29T11:56:35&#43;08:00"/>

<meta itemprop="name" content="C&#43;&#43;primer学习笔记(二)">
<meta itemprop="description" content="字符串、向量和数组 命名空间的using声明 一般我们如果要使用标准库中定义的变量，需要在程序中用namespace::name来表示，例如 st">


<meta itemprop="datePublished" content="2019-03-29T11:56:35&#43;08:00" />
<meta itemprop="dateModified" content="2019-03-29T11:56:35&#43;08:00" />
<meta itemprop="wordCount" content="4416">



<meta itemprop="keywords" content="c&#43;&#43;," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C&#43;&#43;primer学习笔记(二)"/>
<meta name="twitter:description" content="字符串、向量和数组 命名空间的using声明 一般我们如果要使用标准库中定义的变量，需要在程序中用namespace::name来表示，例如 st"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">聚散流沙</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">聚散流沙</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">C&#43;&#43;primer学习笔记(二)</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-03-29 </span>
        <div class="post-category">
            <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"> 编程语言 </a>
            </div>
          <span class="more-meta"> 4416 words </span>
          <span class="more-meta"> 9 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li><a href="#字符串-向量和数组">字符串、向量和数组</a>
<ul>
<li><a href="#命名空间的using声明">命名空间的using声明</a></li>
<li><a href="#标准库类型string">标准库类型string</a>
<ul>
<li><a href="#定义和初始化string对象">定义和初始化string对象</a></li>
<li><a href="#直接初始化和拷贝初始化">直接初始化和拷贝初始化</a></li>
<li><a href="#可以在string对象上的操作">可以在string对象上的操作</a>
<ul>
<li><a href="#string-size-type类型">string::size_type类型</a></li>
<li><a href="#字面值和string对象想加">字面值和string对象想加</a></li>
</ul></li>
<li><a href="#处理string对象中的字符">处理string对象中的字符</a></li>
</ul></li>
<li><a href="#标准库类型vector">标准库类型vector</a>
<ul>
<li><a href="#定义和初始化vector对象">定义和初始化vector对象</a></li>
<li><a href="#向vector中添加元素">向vector中添加元素</a></li>
<li><a href="#vector的一些操作">vector的一些操作</a>
<ul>
<li><a href="#注意缓冲区溢出错误">注意缓冲区溢出错误</a></li>
</ul></li>
</ul></li>
<li><a href="#迭代器">迭代器</a>
<ul>
<li><a href="#迭代器类型">迭代器类型</a></li>
<li><a href="#迭代器运算">迭代器运算</a></li>
</ul></li>
<li><a href="#数组">数组</a>
<ul>
<li><a href="#复杂的数组声明">复杂的数组声明</a></li>
<li><a href="#指针与数组的关系">指针与数组的关系</a></li>
<li><a href="#标准库函数begin和end">标准库函数begin和end</a></li>
<li><a href="#下标和指针">下标和指针</a></li>
<li><a href="#c风格字符串">C风格字符串</a></li>
<li><a href="#使用数组初始化vector对象">使用数组初始化vector对象</a></li>
<li><a href="#多维数组">多维数组</a>
<ul>
<li><a href="#使用指针来遍历多维数组">使用指针来遍历多维数组</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      

<h1 id="字符串-向量和数组">字符串、向量和数组</h1>

<h2 id="命名空间的using声明">命名空间的using声明</h2>

<p>一般我们如果要使用标准库中定义的变量，需要在程序中用namespace::name来表示，例如 std::cout，不过C++提供了一种命名空间声明方法using,在头部使用using namespace::name后就可以在程序中直接使用name而不用加namespace::前缀了。更方便的是我们可以声明整个命名空间，如using namespace std,这样我们就可以直接使用标准命名空间中的所有定义好的成员了。</p>

<p>注意：在头文件中不应该包含using声明，头文件被多个源文件包含可能会产生命名冲突的问题。</p>

<h2 id="标准库类型string">标准库类型string</h2>

<h3 id="定义和初始化string对象">定义和初始化string对象</h3>

<p><img src="https://ws1.sinaimg.cn/large/005Sd4WIly1g1jnmv4ukzj310o0aaahh.jpg" alt="" /></p>

<h3 id="直接初始化和拷贝初始化">直接初始化和拷贝初始化</h3>

<p>用等号(=)初始化变量的一般执行的就是拷贝初始化，而不使用等号的一般就是直接初始化了。</p>

<h3 id="可以在string对象上的操作">可以在string对象上的操作</h3>

<p><img src="https://ws1.sinaimg.cn/large/005Sd4WIly1g1jo11yjdjj310o0hcgww.jpg" alt="" /></p>

<p>一般输入流读取一个单独的字符串，忽略开头的空白（空格、换行、制表符等）直到遇到下一处空白。如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span><span class="c1">//若此处输入为&#34;   hello world&#34;
</span><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">;</span><span class="c1">//则此处只会输出hello，默认忽略空白直到遇见下一处空白结束
</span></code></pre></td></tr></table>
</div>
</div>
<p>若要读取包括空白符，可以使用getline(is,s)函数，此函数读取一整行输入直到遇见换行符为止（读取换行符），并把所读取的内容赋予变量s，但是并不包含换行符号。</p>

<h4 id="string-size-type类型">string::size_type类型</h4>

<p>与一般的内置类型的不同，string类和其它大多数标准库类型定义了几种配套的类型，这些配套类型体现了标准库类型与机器无关的特性。</p>

<p>size_type是一个无符号类型的值，且能存放下任何string对象的大小。
我们可以使用auto或者decltype来推断变量的类型：如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp">    <span class="k">auto</span> <span class="n">len</span>  <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="c1">//len的类型为string::size_type
</span></code></pre></td></tr></table>
</div>
</div>
<p><strong>注意:</strong>由于size_type类型是无符号的，不能与有符号数混用。</p>

<h4 id="字面值和string对象想加">字面值和string对象想加</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">string</span> <span class="n">s</span> <span class="o">=</span><span class="s">&#34;hello&#34;</span><span class="p">;</span>
<span class="n">string</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&#34;world&#34;</span><span class="p">;</span><span class="c1">//正确,字符串字面值可以转换成string类型
</span><span class="c1"></span><span class="n">string</span> <span class="n">s3</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="sc">&#39;q&#39;</span><span class="p">;</span><span class="c1">//正确，字符字面值可以转换成string类型
</span><span class="c1"></span><span class="n">string</span> <span class="n">s4</span> <span class="o">=</span> <span class="s">&#34;hello&#34;</span> <span class="o">+</span> <span class="s">&#34;world&#34;</span><span class="p">;</span><span class="c1">//错误，字面值类型不能直接想加
</span><span class="c1"></span><span class="n">string</span> <span class="n">s5</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&#34;hello&#34;</span> <span class="o">+</span> <span class="s">&#34;world“;//</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div>
<p><strong>注意:</strong>string对象和字面值类型混用时，+号两侧至少要有一个是string类型，这是因为c++时兼容c语言的，所以它的字面值并不是string类型的。</p>

<h3 id="处理string对象中的字符">处理string对象中的字符</h3>

<p><img src="https://ws1.sinaimg.cn/large/005Sd4WIly1g1jox9l2nvj310a12y7wh.jpg" alt="" /></p>

<p>范围for语句可以用于遍历容器内的所有元素，string类型也是一种容器，具体形式如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">for</span> <span class="p">(</span><span class="nl">declaration</span> <span class="p">:</span> <span class="n">expression</span><span class="p">)</span>
    <span class="n">statement</span>
</code></pre></td></tr></table>
</div>
</div>
<p>在实际操作中，我们可能使用如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">string</span> <span class="nf">str</span><span class="p">(</span><span class="s">&#34;hello,world!)</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">str</span><span class="p">)</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//这会把该str对象内的字符一一对应地复制给变量c，auto可以让编译器来决定c的类型
</span></code></pre></td></tr></table>
</div>
</div>
<p>若要改变字符串中的字符，则必须把该循环变量定义成引用类型的，这样才能作用在原字符上。即</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">string</span> <span class="nf">s</span><span class="p">(</span><span class="s">&#34;hello,world!)</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">c</span> <span class="p">:</span> <span class="n">s</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">toupper</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div>
<p>若只要处理一部分字符，则可以使用下标[]和迭代器操作。下标接受的是string::size_type类型，所以它的取值范围在0到s.size()-1，不能越界访问，否则可能引发其它后果。</p>

<h2 id="标准库类型vector">标准库类型vector</h2>

<p>vector表示对象的集合，其中所有的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。这种能容纳其它对象的集合叫做容器。要使用vector则要先#include <vector></p>

<p>vector 是一种类模版，它的使用方法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span><span class="c1">//x保存了int类型的对象
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span><span class="c1">//s保存了string类型的对象
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">file</span><span class="p">;</span><span class="c1">//file保存的是vector对象
</span></code></pre></td></tr></table>
</div>
</div>
<p>某写编译器可能需要老式的声明语句来处理元素为vector的vector对象，如vector<vector<int> &gt;（需要在最后的右括号前面加一个空格）。</p>

<h3 id="定义和初始化vector对象">定义和初始化vector对象</h3>

<p><img src="https://ws1.sinaimg.cn/large/005Sd4WIly1g1jqb8jtomj310o0bqdp4.jpg" alt="" /></p>

<h3 id="向vector中添加元素">向vector中添加元素</h3>

<p>一般常用的操作是先定义一个vector对象清楚需要的元素个数，而是等到运行的时候才把元素添加给它。使用push_back即能在运行时添加元素。
<img src="https://ws1.sinaimg.cn/large/005Sd4WIly1g1jqk1shotj310s0ggnk9.jpg" alt="" />
<strong>注意:</strong> 如果在循环中有可能改变vector对象容器的时候（如添加元素等），不能使用范围for语句。即：范围for语句体内不应该改变其所遍历序列的大小。</p>

<h3 id="vector的一些操作">vector的一些操作</h3>

<p><img src="https://ws1.sinaimg.cn/large/005Sd4WIly1g1jqoywk4rj310s0ecn68.jpg" alt="" /></p>

<p>vector中元素的size也是size_type类型的，不过需要指明它的类型。如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">size_type</span> <span class="c1">//正确
</span><span class="c1"></span><span class="n">vector</span><span class="o">::</span><span class="n">size_type</span> <span class="c1">//错误
</span></code></pre></td></tr></table>
</div>
</div>
<h4 id="注意缓冲区溢出错误">注意缓冲区溢出错误</h4>

<p><img src="https://ws1.sinaimg.cn/large/005Sd4WIly1g1jr0g1rjsj310w0q87wh.jpg" alt="" /></p>

<h2 id="迭代器">迭代器</h2>

<p>迭代器类似于指针，所有的标准库容器都支持迭代器，但是只有只有少数几种才同时支持下标运算符。迭代器也提供了对对象的间接访问。迭代器分有效和无效两种，有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置，其它轻量都属于无效。</p>

<p>与指针不同，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。比如，这些类型都拥有名为begin和end的成员，其中begin返回指向第一个元素的迭代器，而end指向尾元素的下一位置（即一个不存在的元素），end成员返回的迭代器称为尾后迭代器。若容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span>
<span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">e</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="c1">//b和e的类型相同
</span></code></pre></td></tr></table>
</div>
</div>
<p>迭代器运算符</p>

<p><img src="https://ws1.sinaimg.cn/large/005Sd4WIly1g1jrjqbea0j310q0a6aig.jpg" alt="" /></p>

<p><strong>注意：</strong>执行解引用操作的迭代器必须合法并确实指示着某个元素，我们不能对end返回的迭代器进行递增递减或解引用的操作，因为它不实际指示某个元素。</p>

<p><img src="https://ws1.sinaimg.cn/large/005Sd4WIly1g1jrtqpqtmj310e0dmwzt.jpg" alt="" /></p>

<h3 id="迭代器类型">迭代器类型</h3>

<p>一般我们并不知道迭代器的精确类型（其实也无需知道），实际上，那些拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span><span class="p">;</span><span class="c1">//it能读写vector&lt;int&gt;的元素
</span><span class="c1"></span><span class="n">string</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it2</span><span class="p">;</span><span class="c1">//it2能读写string对象的字符
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it3</span><span class="p">;</span><span class="c1">//只能读，不能写
</span><span class="c1"></span><span class="n">string</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">it4</span><span class="p">;</span><span class="c1">//同上
</span></code></pre></td></tr></table>
</div>
</div>
<p>一般来说，我们的迭代器的类型可以由auto自动推断得到，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">cv</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">it1</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="c1">//it1的类型是vector&lt;int&gt;::iterator
</span><span class="c1"></span><span class="k">auto</span> <span class="n">it2</span> <span class="o">=</span> <span class="n">cv</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="c1">//it2的类型是vector&lt;int&gt;::const_iterator
</span></code></pre></td></tr></table>
</div>
</div>
<p>c++11新增加了两个函数分别是cbegin和cend,这可以返回const_iterator，无论原对象本身是否是常量。</p>

<p>某些对vector对象的操作可能使得迭代器失效。我们知道前面说过不要在for循环中向vector对象添加元素，另外一个限制是任何一种可能改变vector对象容器的操作，如push_back，都会使该vector对象的迭代器失效。</p>

<h3 id="迭代器运算">迭代器运算</h3>

<p><img src="https://ws1.sinaimg.cn/large/005Sd4WIgy1g1jzrz9cyqj310o0kqwvf.jpg" alt="" /></p>

<h2 id="数组">数组</h2>

<p>数组初始化需要确定数组的大小</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">};</span><span class="c1">//剩下的元素将会被默认初始化，至于初始化的值是什么由该数组定义的位置有关
</span><span class="c1"></span><span class="kt">int</span> <span class="n">c</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span><span class="c1">//也可以不制定大小，则此时数组的大小由给定的元素多少决定
</span></code></pre></td></tr></table>
</div>
</div>
<p>不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值。</p>

<h3 id="复杂的数组声明">复杂的数组声明</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">//ptrs是含有10个整型指针的数组
</span><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">ref</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">=</span><span class="cm">/*?*/</span><span class="p">;</span><span class="c1">//错误，不存在引用的数组
</span><span class="c1"></span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">Par</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">;</span><span class="c1">//par指向一个含有10个整数的数组
</span><span class="c1"></span><span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">arrR</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span><span class="c1">//arrR引用一个含有10个整数的数组
</span></code></pre></td></tr></table>
</div>
</div>
<p>内置数组的下标类型被定义为size_t类型，被定义在cstddef头文件中。</p>

<h3 id="指针与数组的关系">指针与数组的关系</h3>

<p>在使用数组的时候编译器一般会把它转换成指针，数组名就是指针常量，它的值不变指向的是数组中第一个元素的位置。
当auto作用于数组名时，得到的是一个指针</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">};</span>
<span class="k">auto</span> <span class="nf">b</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="c1">//ia2是一个整型指针，指向ia的第一个元素 
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">p</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//地址0x7ffee580fb20
</span><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//地址0x7ffee580fb20
</span><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;&amp;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//地址0x7ffee580fb20
</span><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//地址0x7ffee580fb24
</span><span class="c1"></span><span class="n">cout</span><span class="o">&lt;&lt;&amp;</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//地址0x7ffee580fb3c
</span></code></pre></td></tr></table>
</div>
</div>
<p>从中我们可以知道，对于数组名有三种特殊情况：
- sizeof(a)，得到的是大小是整个数组的大小
- &amp;a,对数组名取地址，得到的是指向整个数组的指针，此时&amp;a+1，则加上了整个数组大小的字节
- 当decltype作用于数组名时，得到的类型是一个数组。</p>

<h3 id="标准库函数begin和end">标准库函数begin和end</h3>

<p>尽管我们能得到尾后指针，但是此用法容易出错。为了让指针的使用更简单、更安全，C++11新标准引入了两个名为begin和end的函数。这两个函数不是成员函数，因为数组不是类类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">ia</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">beg</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="n">ia</span><span class="p">);</span><span class="c1">//指向ia首元素的指针
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="n">end</span><span class="p">(</span><span class="n">ia</span><span class="p">)</span><span class="err">；</span><span class="c1">//指向arr尾元素的下一位置的指针
</span></code></pre></td></tr></table>
</div>
</div>
<p><img src="https://ws1.sinaimg.cn/large/005Sd4WIgy1g1l32n0td4j310q04ktes.jpg" alt="" /></p>

<h3 id="下标和指针">下标和指针</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">ia</span> <span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ia</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="c1">//p指向索引为2的元素
</span><span class="c1"></span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="c1">//p[1]等价于 *(p+1),就是ia[3]表示的那个元素
</span><span class="c1"></span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">];</span><span class="c1">//p[-2]是ia[0]表示的那个元素
</span></code></pre></td></tr></table>
</div>
</div>
<p>内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样。</p>

<h3 id="c风格字符串">C风格字符串</h3>

<p>c风格字符串是存放在字符数组中并以&rsquo;\0&rsquo;结尾，一般利用指针来操作这些字符串。
<img src="https://ws1.sinaimg.cn/large/005Sd4WIgy1g1l3jdpt0qj310q092455.jpg" alt="" />
尽量使用string标准库，c风格字符串若操作不当，容易引发安全漏洞。
但是某个时刻我们需要必须需要使用c风格的字符串时，string专门提供了一个名为c_str的成员函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">c_str</span><span class="p">();</span><span class="cm">/*此处无法保证c_str函数返回的数组一直有效，后面若s的值被改变可能使该数组失去效果，所以，如果执行完c_str()函数后程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份。
</span></code></pre></td></tr></table>
</div>
</div>
<h3 id="使用数组初始化vector对象">使用数组初始化vector对象</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">int_arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ivec</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">int_arr</span><span class="p">),</span><span class="n">end</span><span class="p">(</span><span class="n">int_arr</span><span class="p">));</span><span class="c1">//指明一个范围，其中end返回的是指向尾元素的下一位置。
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">subVec</span><span class="p">(</span><span class="n">int_arr</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">int_arr</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div>
<h3 id="多维数组">多维数组</h3>

<p>c++中所谓的多维数组其实指的是数组的数组。
使用范围for语句处理多维数组时除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">ia</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">];</span><span class="c1">//假设已经赋值
</span><span class="c1"></span>
<span class="cm">/*此处的row必须是引用类型，如果不加引用，则编译器会把row初始化为int*的类型，则内层循环试图变量一个int*，肯定是不合法的*/</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">row</span> <span class="o">=</span> <span class="n">ia</span><span class="p">)</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">col</span><span class="p">:</span><span class="n">row</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">col</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>
<h4 id="使用指针来遍历多维数组">使用指针来遍历多维数组</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">p</span><span class="o">=</span><span class="n">ia</span><span class="p">;</span><span class="n">p</span><span class="o">!=</span><span class="n">ia</span><span class="o">+</span><span class="mi">3</span><span class="p">;</span><span class="o">++</span><span class="n">p</span><span class="p">){</span>
    <span class="c1">//q指向4个整数数组的首元素，
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">q</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span><span class="n">q</span> <span class="o">!=</span> <span class="o">*</span><span class="n">p</span><span class="o">+</span><span class="mi">4</span><span class="p">;</span><span class="o">++</span><span class="n">q</span><span class="p">)</span>
        <span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">q</span><span class="o">&lt;&lt;</span><span class="sc">&#39; &#39;</span><span class="p">;</span>
    <span class="n">cont</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">//类型别名简化多维数组的指针
</span><span class="c1"></span><span class="k">using</span> <span class="n">int_array</span> <span class="o">=</span> <span class="kt">int</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="k">for</span><span class="p">(</span><span class="n">int_array</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span><span class="n">ia</span><span class="p">;</span><span class="n">p</span><span class="o">!=</span><span class="n">ia</span><span class="o">+</span><span class="mi">3</span><span class="p">;</span><span class="o">++</span><span class="n">p</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">q</span><span class="o">=*</span><span class="n">p</span><span class="p">;</span><span class="n">q</span><span class="o">!=*</span><span class="n">p</span><span class="o">+</span><span class="mi">4</span><span class="p">;</span><span class="o">++</span><span class="n">q</span><span class="p">)</span>
        <span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">q</span><span class="o">&lt;&lt;</span><span class="sc">&#39; &#39;</span><span class="p">;</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//begin,end版
</span><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="n">ia</span><span class="p">);</span><span class="n">p</span><span class="o">!=</span><span class="n">end</span><span class="p">(</span><span class="n">ia</span><span class="p">);</span><span class="o">++</span><span class="n">p</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">q</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span><span class="n">q</span><span class="o">!=</span><span class="n">end</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span><span class="o">++</span><span class="n">q</span><span class="p">)</span>
        <span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">q</span><span class="o">&lt;&lt;</span><span class="sc">&#39; &#39;</span><span class="p">;</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">JackyLove</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2019-03-29
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/c&#43;&#43;/">c&#43;&#43;</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/c&#43;&#43;primer-3/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">C&#43;&#43;primer学习笔记(三)</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8hugo%E5%92%8Cgithub%E6%9D%A5%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B/">
            <span class="next-text nav-default">记一次使用Hugo和Github来搭建个人博客过程</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  <span id="/post/c&#43;&#43;primer-2/" class="leancloud_visitors" data-flag-title="C&#43;&#43;primer学习笔记(二)">
    <span class="post-meta-item-text">文章阅读量 </span>
    <span class="leancloud-visitors-count">1000000</span>
    <p></p>
  </span>
  <div id="vcomments"></div>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script type="text/javascript">
    new Valine({
        el: '#vcomments' ,
        appId: 'xPwmFUoHVqraVIVlAt2Xch9M-gzGzoHsz',
        appKey: 'VP1APko2CdGfydmf7xOplDur',
        notify:  false , 
        verify:  false , 
        avatar:'', 
        placeholder: '请说点什么吧...',
        visitor:  true 
    });
  </script>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="https://stackoverflow.com/users/8640064/jackylove" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="https://github.com/jacklov3" class="iconfont icon-github" title="github"></a>
      <a href="https://www.instagram.com/jacky1ove/" class="iconfont icon-instagram" title="instagram"></a>
  <a href="https://www.jackylove.me/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2018 - 
    2019
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">JackyLove</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>








</body>
</html>
